\chapter{Dynamic Project Naming}\label{sec:project-naming}


Dynamic project naming can be achieved by creating a simple Python module that returns
a project name string in the desired format.  This concept requires a bit of background
in Python programming to achieve.  In most cases, the code required will be simple.
Complex cases will require a bit more of a Python background.  As always, 
Checkmarx Professional Services can assist with Python expertise if needed.

The project naming script is invoked with parameters that include the JSON context of the event
and a service object for interacting with the API of the SCM that generated the event.


\section{Configuration}

An example YAML configuration is shown below.  The \intlink{sec:yaml-root}{\texttt{script-path}} element
should be set to a directory where Python naming scripts have been mapped.  The directory
mapping method depends on how the container is executed; one approach would be to map
a local directory to the running \cxoneflow container when creating a
\intlink{sec:container-creation}{container instance}.

With the \texttt{script-path} element configured, each service definition where the script applies
is configured with the \intlink{sec:project-naming-elements}{project naming elements}.  In the YAML
example, the \texttt{project-naming.module} element is configured with the module name \texttt{adoe\_naming}.
This means that in the directory located at \texttt{/scripts} (set with the root \texttt{script-path} element),
a file named \texttt{adoe\_naming.py} contains the code that will be executed to produce a project name.

With the given YAML example, \cxoneflow will attempt to load the Python module at \texttt{/scripts/adoe\_naming.py}
upon startup.  The startup logic will then attempt to find the appropriate method to call for dynamic project
name generation.  If the module does not load successfully or is otherwise malformed, \cxoneflow will stop with error.

The \texttt{project-naming.update-name} configuration element in the YAML example is set to \texttt{True}.  This indicates that
projects previously created with a default project name, if found, will be renamed with the dynamic project name.  This
renaming activity occurs only upon handling an event generated by a push or pull-request for the corresponding
repository.  If \texttt{project-naming.update-name} is set to \texttt{False} and a project with the default name
is found when handling an event, the existing project is used when starting the scan.

\input{operation/project_naming_minimal_example.tex}


\section{Name Selection Logic}

Dynamic project naming is a transformation activity to take data elements from an SCM-generated event produce
a project name with those elements.  The default project name convention follows the SCM repository organization
scheme and thus varies by SCM.  If \cxoneflow is configured to handle events generated from more than one SCM type,
it should be expected that a dynamic naming script would be required for each configured SCM type.

In the absence of a dynamic project naming configuration, default project names will be used.

When an event is handled by \cxoneflow and dynamic project naming is configured, the following logic is applied
to select the project name selected for the scan:

\begin{enumerate}
  \item If neither the dynamic project name or default project name exists, a new project with the dynamic project name is created.
  \item If the dynamic project name exists, it is selected.
  \item If the dynamic project name does not exist:
  \begin{enumerate}
    \item If \texttt{project-naming.update-name} is \texttt{True}, the default project is renamed using the dynamic project name
    and the dynamic project name is selected.
    \item If \texttt{project-naming.update-name} is \texttt{False}, the default project name is selected.
  \end{enumerate}
\end{enumerate}

Adding a configuration for dynamic project names in a system that has been operational will not alter scan history
for any projects.  Depending on configuration options, projects can be renamed but will retain all other aspects
of the project prior to the name change.


\section{Implementation Guidelines}

Python is a general purpose programming language that allows nearly unlimited possibilities for what is
executed upon invocation of the dynamic project naming module.  The intention of this feature is not, however,
to act as a general purpose integration point.  Dynamic project naming scripts that execute outside of the
guidelines in this section is considered out-of-scope for any supportability.

\subsection{Execution Time}

The intention of the dynamic project naming feature is to provide the ability to extract data from the
event and/or the SCM associated with the service definition handling the event.  As such, the
average execution time of a dynamic project naming script should be less than 1 second.

\subsection{Additional Third-Party Python Modules}

Adding additional Python modules beyond what is used by \cxoneflow is considered out-of-scope.

\subsection{Local File Access}

While it is possible to perform local file access via Python built-in libraries, doing so
is considered out-of-scope.

\subsection{Statelessness}

Maintaining any in-memory state in across invocations of a dynamic project naming script is considered out-of-scope.
If the implementation requires maintaining state through using external services, it should be done so within the
execution time guidelines.

\subsection{Robustness of Implementation}

It is assumed that the implementation of a dynamic project naming script is robust given dynamic project naming scripts
are intended to be simple implementations.  A dynamic projecting naming script that fails with an exception, returning \texttt{None} due to an error
condition, or returns the same name for multiple repositories will cause scans to be created in incorrect projects.  If
a dynamic project naming script is failing with high frequency, consider simplifying the implementation.


\section{Authoring Dynamic Project Naming Scripts}

\subsection{Security Warning}

The dynamic project naming scripts that execute in \cxoneflow are written in Python with execution in the context of
the \cxoneflow daemon process.  Given that Python is a general purpose programming language, anything that can be executed
as a running Python program can be executed during the dynamic project name module execution.  Care should be taken to
prevent the content of the dynamic project naming scripts from being modified by unauthorized individuals.

\subsection{Dynamic Project Naming API Implementation}

A dynamic project naming module must implement a single method named \texttt{event\_project\_name\_factory}. The code
listing below shows the prototype of \texttt{event\_project\_name\_factory}:

\begin{code}{Dynamic Project Naming Method Prototype}{}{}
async def event_project_name_factory(context : EventContext, scm_service : BasicSCMService) -> str : ...
\end{code}

\cxoneflow will invoke the instance of \texttt{event\_project\_name\_factory} when orchestrating a scan and expect
it to return a string value for the dynamic project name.  If \texttt{event\_project\_name\_factory} returns \texttt{None}
or throws an exception, the default project name is used.

\subsubsection{\texttt{EventContext} Parameter}

The \texttt{EventContext} parameter contains the elements of the event that caused a scan to be orchestrated.
The \texttt{EventContext.headers} property is a dictionary containing headers sent along with the event.  The
\texttt{EventContext.message} property is a dictionary containing the JSON content of the event.

The event message content can vary and guard code should be used to ensure interpretation of the event properly.
Events that orchestrate scans can be formed differently by the SCM for push and pull-request events.  Events may also
come from events received through the \intlink{sec:kickoff}{Kickoff} endpoints for each SCM.  The content for Kickoff
messages varies for each SCM type.

\subsubsection{\texttt{BasicSCMService} Parameter}

The \texttt{BasicSCMService} parameter is an object to allow for performing authenticated SCM API calls.  It is useful for
cases where additional information from the SCM API is needed to fully form the project name.  Performing API calls may
lead to long execution times for the dynamic project naming script.

\subsection{Debugging Dynamic Project Naming Scripts}

Debugging script execution with an IDE is possible using the techniques described in Appendix \ref{sec:cxoneflow-development}.
This loads \cxoneflow in a debug development mode which will allow setting breakpoints in the dynamic project naming code.

Another option is to use the Python built-in \texttt{logging} module.  Logging output from the dynamic naming script can be
observed along with any other logging output produced by \cxoneflowns.  Using the logging output, it is possible to track
execution logic and view the data stored in any variables.

\subsection{Example Code}

\subsubsection{Simple Module Example}

The listing below for the \texttt{bbdc\_naming} module creates a project name from
the event context in the format of \texttt{<project key>\_<repository name>}:

\begin{code}{Simple Dynamic Project Naming Module}{[bbdc\_naming.py]}{}
from api_utils.auth_factories import EventContext
from scm_services import BasicSCMService
import logging

async def event_project_name_factory(context : EventContext, scm_service : BasicSCMService) -> str:
  # Get an instance of the logger
  log = logging.getLogger(__name__)

  # Output the event context to the debug log
  log.debug(context)


  # Look for the repository element that is included in push/pull-request events
  if 'repository' in context.message.keys():
    slug = context.message['repository']['slug']

    # Check for the project element that has the project key
    if 'project' in context.message['repository'].keys():
      key = context.message['repository']['project']['key']
      return f"{key}_{slug}"

  # Failure causes the default project name to be used
  return None
\end{code}

\subsubsection{Complex Module Example}

The dynamic project naming script in the code listing for the \texttt{adoe\_naming}
module is shown below.  This is used to create a project with the naming convention:\\\\
\texttt{<first 6 or less chars of collection>\_<project name>\_<repo name>}\\

In this example, an authenticated API call is made to retrieve the collection name
for the collection id provided in the event context.

\begin{code}{Complex Dynamic Project Naming Module}{[adoe\_naming.py]}{}
from api_utils.auth_factories import EventContext
from scm_services import BasicSCMService

def normalize_collection_name(col_name):
    if len(col_name) < 6:
      return col_name
    else:
      return col_name[0:6]

async def event_project_name_factory(context : EventContext, scm_service : BasicSCMService) -> str:
  if 'resource' in context.message.keys():
    # Webhook event
    repo_name = context.message['resource']['repository']['name']
    project_name = context.message['resource']['repository']['project']['name']
    collection_id = context.message['resourceContainers']['collection']['id']

    # Perform a GET using the scm_service object.
    collection_lookup_resp = await scm_service.exec("GET", f"/_apis/projectcollections/{collection_id}", event_context=context)

    if not collection_lookup_resp.ok:
      return None

    collection_name = collection_lookup_resp.json()['name']
  else:
    # Kickoff event
    collection_name = context.message['collection_name']
    repo_name = context.message['repo_name']
    project_name = context.message['project_name']

  return f"{normalize_collection_name(collection_name)}_{project_name}_{repo_name}"
\end{code}




