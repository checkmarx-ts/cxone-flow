\chapter{Distributed Resolver Agents}\label{sec:resolver-agents}

\section{Overview}

Executing Software Composition Analysis (SCA) scans in \cxone will gather results
by analyzing packages found in the dependency tree for the code submitted for scan.  
The \cxone SCA scan first obtains a dependency tree, then performs an analysis
of the packages found in the dependency tree. The dependency
tree is obtained by executing the same build tools normally used to develop and produce a
distributable software package.  This execution is performed using two methods: server-side 
dependency tree resolution and client-side dependency tree resolution with \scaresolver.

\subsection{Server-Side Dependency Tree Resolution}

The dependency analysis for the code submitted to \cxone is performed
in the server-side \cxone environment by executing the package managers that match the composition of the code
under scan.  This generally works sufficiently when the code references only publicly-available, open-source
packages and is compatible with the package manager tooling installed in the \cxone environment.  

Not all software is composed of only publicly available packages nor does it always use package manager tooling
that is compatible with those installed in the \cxone environment.  Incompatibilities usually manifest
when some of the following issues are observed:

\begin{itemize}
  \item The dependency tree is incomplete when software references a private package repository.
  \item The dependency tree is incomplete when the code under scan is incompatible with the 
  package manager tools installed in the \cxone environment.
\end{itemize}

If the server-side dependency resolution is not producing accurate results, the general solution is to
perform a client-side dependency tree resolution with \scaresolver. 

\subsection{Client-Side Dependency Tree Resolution with \scaresolver}

The \scaresolver is typically scripted to execute in
a pipeline prior to the scan submission to \cxone.  This performs the dependency resolution
in the same environment as the code builds, which will generally resolve any tooling compatibility or network connection
problems.  

Since \cxoneflow is primarily driven by asynchronous web hook events and does not invoke a pipeline
where dependency resolution can be scripted, the distributed resolver agents can perform the dependency resolution using
\scaresolver. The diagram in Figure \ref{fig:resolver-agent-diagram} shows a typical deployment of the resolver agent.  


The resolver agent is deployed such that it can execute the same build tooling as is executed during the build
in a CI/CD pipeline. The \cxoneflow server delegates \scaresolver execution to the resolver agent to perform the dependency tree
resolution; this technique is similar to how a CI/CD pipeline delegates build script execution to a system with the correct
build environment.  The build execution is sometimes performed on a self-hosted "runner" agent or executed using a container with a specified tag. 

This execution delegation technique typically results in execution of the build tools that are appropriately
configured for the normal build.  The typical CI/CD pipeline runner will also have the correct network connection paths
needed to communicate to private package repositories.


\begin{figure}[ht]
  \includegraphics[width=\textwidth]{graphics/cxoneflow-diagrams-Resolver Agent Diagram.png}
  \caption{Resolver Agent Deployment Diagram}
  \label{fig:resolver-agent-diagram}
\end{figure}


\input{resolver/server.tex}
\input{resolver/agent.tex}


